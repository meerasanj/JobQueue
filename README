Queue Class: The Queue class is utilized in the driver program to manage the flow of jobs through different stages of processing. The TimeShare class creates several instances of the Queue class (inputQueue, jobQueue, and finishQueue) and also uses methods from the Queue class, such as enqueue, dequeue, front, and isEmpty. The queue class represents a queue implemented as a circular linked list. The lastNode ponts to the item at the rear of the queue, while the next field of lastNode points to the front of the queue. The enqueue method adds a new item to the queue, handling 2 cases. When the queue is empty, a new node is created and becomes both the first and last node. When the queue is not empty, the new node is inserted after the last node, and the last node's next field is updated. The dequeue method removes and returns an item from the queue. If the queue is empty, a QueueException is thrown. When the queue has one item, the last node is set to null. When the queue has more than one item, the first node is removed and the last node's next field is updated. The front method returns the node at the front of the queue, but throws an exception if the queue is empty. The isEmpty method is a boolean method that checks if the queue is empty. 

Job Class: The Job class represents a job control block storing information about a particular job. The attributes of Job.java include jobName, arrivalTime, startTime, runTime, waitTime, and turnTime. The TimeShare program utilizes the Job class to store information about each job. For example, I created instances of the Job class with the job name, arrival time, and run time from the input file.

TimeShare Class (Driver Program): The driver program interacts with the Job and Queue classes to read input, process jobs, and generate the summary report. The main method is the entry point to the program, which uses a Scanner to read user input and call the methods of readInputFile, process, and printSummaryReport. The readInputFile method takes in parameters of the inputQueue and Scanner, which then populates the inputQueue by reading the input file line by line. The process method takes in inputQueue, jobQueue, and finishQueue as parameters in order to simulate the processing of jobs and update counters. The main processing loop in this method continues until the inputQueue or processQueue is empty. First, it checks if the inputQueue is not empty. If the first job in the input queue has an arrival time equal to the current clock time, it is moved to the job queue. This ensures that jobs are placed in the jobQueue at the correct arrival time, even if the CPU is busy. Then, it checks if the job queue is not empty. If the first job in the job queue has already started (start time is not -1) and its run time is equal to the current clock time minus start time, it indicates that the job has completed.
Completed jobs are removed from the jobQueue and placed on the finishQueue, also updating the turnTime. Next, it checks if the job queue is not empty. If the first job in the job queue has an arrival time less than or equal to the current clock time and it hasn't already been started (start time is -1), the job's start time is updated to the current clock time, and its wait time is set. The process method also updates the idleTime counter if the jobQueue is empty and the inputQueue is not empty and clock is updated by 1. The printSummaryReport method takes the parameter of finishQueue. While the finishQueue is not empty, the jobName, arrivalTime, startTime, runTime, waitTime, and turnTime is printed and totalWaitTime, totalTurnaroundTime, totalRunTime, and count (# of jobs) are updated. Lastly, calculations are printed. averageWaitTime is calculated by dividing the totalWaitTime by count. The cpuUsage, which is the same as totalRunTime, as well as idleTime (calculated earlier) are printed. The cpuUsagePercentage is calculated by dividing the cpuUsage by cpuUsage + idleTime, all multiplied by 100. 

Sample Input (also in jobs3.dat): 
job1 01 04
job2 03 02 
job3 06 01
job4 08 05
job5 10 02

Sample Output: 

Job Control Analysis: Summary Report

job id  arrival  start  run  wait  turnaround
        time     time   time time  time
------  -------  -----  ---- ----  ----------
job1	1	1	1	0	1
job2	3	3	4	0	4
job3	6	7	1	1	2
job4	8	8	5	0	5
job5	10	13	2	3	5

Average Wait Time => 0.80
CPU Usage =>  13.00
CPU Idle => 1.00
CPU Usage (%) => 92.86%

Explanation: 
Average Wait Time is calculated by adding the individual wait times of all jobs. (0 + 0 + 1 + 0 + 3) / 5 = 4 / 5 = 0.8
CPU Usage is calculated by the adding the run times of all jobs. 1 + 4 + 1 + 5 + 2 = 13
CPU Idle is calculated when the jobQueue is empty but the inputQueue is not empty. The CPU is idle for 1 unit, in this scenario. 
CPU Usage (%) is calculated by dividing the cpuUsage by cpuUsage + idleTime, all multiplied by 100. (13 / (13 + 2)) * 100 = 92.86%

